## 进程、线程、协程

进程关注通信，线程关注同步

### 定义

- 进程：是资源分配的最小单位
  - 有自己独立的内存空间，不同进程之间内存不共享，通讯效率低，切换开销大

- 线程：是CPU调度的最小单位
  - 可以有多线程，共享进程的内存空间，通讯效率高，切换开销小

- 协程：协程是微线程，在子程序内部执行，可在子程序内部中断，转而执行别的子程序，在适当的时候再返回来接着执行。

### 状态

- 线程
  - 新建(New)、就绪(Start)、运行(Running)、阻塞(SLeep / wait / IO)、死亡(Destroy)

### 通信方式

- 进程间
  - 消息队列、共享内存、信号量、Socket
- 线程间
  - volatile、wait/notify机制、ThreadLocal

### 同步方式

- 线程间
  - 互斥锁、条件变量、读写锁、信号量（PV操作）、信号处理

### 上下文切换

- 线程
  - 导致线程上下文切换的原因
    - 线程的cpu时间片用完
    - 垃圾回收
    - 有优先级更高的线程需要运行
    - 线程调用了sleep、yield、wait、join、park、synchronized、lock等
  - 当发生上下文切换时，由操作系统保存当前线程的状态，然后切换到另外一个线程运行，由程序计数器实现
    - 保存的状态有：栈帧的信息（局部变脸，操作数栈，返回地址）
  - 频繁的上下文切换会影响性能

### 优点

- 协程
  - 协程执行效率极高。协程不需要多线程的锁机制，可以不加锁的访问全局变量，所以上下文的切换非常快。
  - 执行协程只需要极少的栈内存（大概是4～5KB），而默认情况下，线程栈的大小为1MB。
  - 协程直接操作栈基本没有内核切换的开销，所以切换开销比线程少。

## 系统中断

### 软中断

### 硬中断

## 锁机制

### 死锁

- 死锁就是多线程之间争夺系统共享资源，然后出现相互等待的情况
  - 互斥：已获取的资源不允许其他进程访问，知道资源释放才能访问
  - 请求和保持：已有资源，然后要访问其他进程占有的资源，但是本身的资源不释放
  - 不可抢占：获取的资源未使用完之前都不可被访问
  - 循环等待：存在进程之间资源的循环等待
- 死锁的解决方法
  - 所有资源一次申请，或者逐步申请，用完释放
  - 让使用同一把锁的多个线程的加锁顺序一致
  - 设置获取锁的超时时间，没得到资源则释放已有资源
  - 死锁检测，查代码防止死锁
    - console工具
    - jps定位进程，jstack导出dump日志，定位死锁代码
- 一个线程要获取多把锁容易出现死锁
- 出现死锁怎么办
  - 重启或者kill



## 系统调度

### LRU

## 拥塞控制

### 为什么需要拥塞控制

- A给B发送数据，A迟迟没有收到B的ACK，那么A会觉得B没收到（丢失），A会重新发送
- 实际情况可能是网络拥塞了，A重复发送数据会导致网络更加拥塞，所以需要拥塞控制

### 拥塞控制策略		

- 刚开始以指数增长的速度发送数据包（1，2，4...），到达某个**阈值**后按线性速度发送数据包（1，2，3....），我们也把 A 一次性连续发送多少个数据包称之为**拥塞窗口**
- 指数增长阶段称为**慢启动**，线性增长阶段称为**拥塞避免**
- 当增长到某个值后肯定会出现**超时事件**，可以认为是出现网络拥塞了，暂且称这个值为**瓶颈值**，此时我们将阈值改为这个瓶颈值的一半，然后拥塞窗口从0开始增长
- 超时事件还有可能是数据包丢失了
  - 假设A给B发了m1,m2,m3,m4....
  - 当A连续收到三个确认m2的ACK时，且m3还没有发送超时事件，A就知道B的m3丢失了，A会快速重传m3，然后将阈值修改为瓶颈值的一半，然后拥塞窗口从阈值开始增长

## 用户态和内核态

- 用户态
- 内核态
  - 系统调用和中断
- 用户态 --> 内核态
  - CPU管理、内存管理、诊断和测试



















